//package main
//
//import (
//
//    "fmt"
//    "sync"
//)
//
//func consumer(messages <- chan int, shutdown <- chan int, wg *sync.WaitGroup) {
//    defer wg.Done()
//    for {
//        select {
//        case message, ok := <- messages:
//            //do something.
//            if ok {
//                fmt.Println(message)
//            } else {
//                //no data , exit.
//                fmt.Println("no data, exit.")
//                return
//            }
//        case _ = <- shutdown:
//            //we `re done!
//            //shutdown now , messages buffered channel data may be lost.
//            fmt.Println("all done!")
//            return
//        }
//    }
//}
//
//func main() {
//    shutdown := make(chan int)
//    messages := make(chan int, 16)
//
//    wg := &sync.WaitGroup{}
//    wg.Add(1)
//    go consumer(messages, shutdown, wg)
//    for i := 0; i < 10; i++ {
//        messages <- i
//    }
//    close(messages)
//    fmt.Println("wait!")
//    wg.Wait()
//
//
//}

package main

import (
	"fmt"
	"runtime"
	"strconv"
	"sync"
	"time"
)

//type AutoGenerated struct {
// Age int    `json:"age"`
// Name   string `json:"name"`
// Child []int `json:"child"`
//}
//
//func main() {
//     jsonStr1 := `{"age": 14,"name": "potter", "child":[1,2,3]}`
//     a := AutoGenerated{}
//     json.Unmarshal([]byte(jsonStr1), &a)
//     aa := a.Child
//     fmt.Println(aa)
//
//     jsonStr2 := `{"age": 12,"name": "potter", "child":[3,4,5,7,8,9]}`
//     json.Unmarshal([]byte(jsonStr2), &a)
//     fmt.Println(aa)
//}

//func main() {
//	//file, err := os.Open("D:\\GoleGolas\\随手记\\端口扫描器\\log\\192.168.3.5_port.txt")
//	//if err != nil {
//	//	fmt.Println(err)
//	//	return
//	//}
//	//defer file.Close()
//	//
//	//fileinfo, err := file.Stat()
//	//if err != nil {
//	//	fmt.Println(err)
//	//	return
//	//}
//	//
//	//filesize := fileinfo.Size()
//	//buffer := make([]byte, filesize)
//	//
//	//bytesread, err := file.Read(buffer)
//	//if err != nil {
//	//	fmt.Println(err)
//	//	return
//	//}
//	//fmt.Println("bytes read: ", bytesread)
//	//fmt.Println("bytestream to string: ", string(buffer))
//	content, err := ioutil.ReadFile("D:\\GoleGolas\\随手记\\端口扫描器\\log\\192.168.3.5_port.txt")
//	if err != nil {
//		panic(err)
//	}
//	fmt.Println(string(content))
//}

func new1() {
	newports := []int{22, 25, 110, 111, 3306, 4000, 4369, 5672, 8080, 9104, 9913, 25672, 35729}
	oldports := []int{22, 25, 110, 111, 3306, 4369, 5672, 8080, 9104, 9913, 25672}
	//newports := []int{110, 111, 22, 25, 9913, 35729, 9104, 5672, 4369, 4000, 3306, 25672, 8080}
	//oldports := []int{110, 111, 22, 25, 5672, 3306, 9104, 35729, 4369, 4000, 9913, 25672, 8080}
	fmt.Println(newports)
	fmt.Println(oldports)
	for i := range newports {
		for j := 0; j < len(oldports); j++ {
			if newports[0] == oldports[j] {
				fmt.Println("有相同的端口", newports[0], i)
				newports = newports[1:]
			}
		}
		fmt.Println(newports)
		fmt.Println("新增端口", newports[0], i)
		//fmt.Println(len(newports))
		if len(newports) > 1 {
			newports = newports[1:]
		} else {
			break
		}
	}

}
func new2() {
	//newports := []int{22, 25, 110, 111, 3306, 4000, 4369, 5672, 8080, 9104, 9913, 25672, 35729}
	//oldports := []int{22, 25, 110, 111, 3306, 4369, 5672, 8080, 9104, 9913, 25672}
	oldports := []int{22, 25, 110, 111, 3306, 4000, 4369, 5672, 8080, 9104, 9913, 25672, 35729}
	newports := []int{22, 25, 110, 111, 3306, 4369, 5672, 8080, 9104, 9913, 25672}
	fmt.Println(newports)
	fmt.Println(oldports)
	for i := range newports {
		if InIntSlice(oldports, newports[i]) {
			fmt.Println("相同的端口")
		} else {
			fmt.Println("新增端口：", newports[i])
		}
	}
	for i := range oldports {
		if InIntSlice(newports, oldports[i]) {
			fmt.Println("相同的端口")
		} else {
			fmt.Println("减少端口：", oldports[i])
		}
	}

}

func InIntSlice(haystack []int, needle int) bool {
	for _, e := range haystack {
		if e == needle {
			return true
		}
	}
	return false
}

func new3() {
	defer func() { fmt.Println("打印前") }()
	defer func() { fmt.Println("打印中") }()
	defer func() { fmt.Println("打印后") }()

	panic("触发异常")
}

func new4() (result int) {
	defer func() {
		result++
	}()
	return 0
}

func new5() (t int) {
	t = 5
	defer func() {
		t = t + 5
	}()
	return t
}

func new6() (r int) {
	defer func(r int) {
		r = r + 5
	}(r)
	return 1
}

func new7() {
	i := 0
	defer fmt.Println("a:", i)
	//闭包调用，将外部i传到闭包中进行计算
	defer func(j int) {
		fmt.Println("b:", j)
	}(i)
	//闭包调用，捕获同作用域下的i进行计算
	defer func() {
		fmt.Println("c:", i)
	}()
	i++
}

func G() {
	defer func() {
		//goroutine外进行recover
		if err := recover(); err != nil {
			fmt.Println("捕获异常:", err)
		}
		fmt.Println("c")
	}()
	//创建goroutine调用F函数
	go F()
	time.Sleep(time.Second)
}

func F() {
	defer func() {
		fmt.Println("b")
	}()
	//goroutine内部抛出panic
	panic("a")
}

type student struct {
	Name string
	Age  int
}

func new8() {
	runtime.GOMAXPROCS(1)
	wg := sync.WaitGroup{}
	wg.Add(20)
	for i := 0; i < 10; i++ {
		go func() {
			fmt.Println("A: ", i)
			wg.Done()
		}()
	}
	for i := 0; i < 10; i++ {
		go func(i int) {
			fmt.Println("B: ", i)
			wg.Done()
		}(i)
	}
	wg.Wait()
}

func calc(index string, a, b int) int {
	ret := a + b
	fmt.Println(index, a, b, ret)
	return ret
}

//func main() {
//	a := 1
//	b := 2
//	defer calc("1", a, calc("10", a, b))
//	a = 0
//	defer calc("2", a, calc("20", a, b))
//	b = 1
//}

//type UserAges struct {
//	ages map[string]int
//	sync.Mutex
//}
//
//func (ua *UserAges) Add(name string, age int) {
//	ua.Lock()
//	defer ua.Unlock()
//	//ua.ages = make(map[string]int)
//	ua.ages[name] = age
//}
//
//func (ua *UserAges) Get(name string) int {
//	if age, ok := ua.ages[name]; ok {
//		return age
//	}
//	return -1
//}
//
//func main() {
//	a := new(UserAges)
//	a.Add("123", 123)
//	fmt.Println(a.Get("123"))
//}

//func main() {
//	m := make(map[int]int)
//
//	go func() {
//		// 不停地对map进行写入
//		for {
//			m[1] = 1
//		}
//	}()
//
//	go func() {
//		// 不停地对map进行读取
//		for {
//			_ = m[1]
//		}
//	}()
//
//	fmt.Scanln()
//}

//type SyncMap struct {
//	mymap map[string]string
//	//读写锁包含一对相关的锁，读锁用于只读操作，写锁用于写操作。读锁可能由多个读线程同时运行，写锁是唯一的。
//	// * 读锁和写锁之间是互斥的，同一时间只能有一个在运行。但是可以有多个线程同时读取数据。
//	// * 写入数据之前必须重新确认(ReCheck)状态，因为其他的线程可能会拿到写锁再一次修改我们已经修改过的值。这是因为前一个线程拿到写锁之后，后面的线程会被阻塞。当前一个线程释放写锁之后，被阻塞的线程会继续运行完成被阻塞的部分代码，所以才会出现这样的情况。
//	// * 当某一个线程上了写锁之后，自己仍然可以上读锁，之后在释放写锁，这是一种降级(Downgrade)的处理方法。
//	*sync.RWMutex //读写锁
//}
//
//var smap SyncMap   //公有的访问map
//var done chan bool //通道，是否完成
//func main() {
//	smap = SyncMap{map[string]string{}, new(sync.RWMutex)}
//	done = make(chan bool, 1000)
//
//	go func() {
//		for {
//			smap.Lock()
//			smap.mymap["1"] = "1"
//			smap.Unlock()
//			done <- true
//			time.Sleep(1 * time.Millisecond)
//		}
//	}()
//
//	go func() {
//		for {
//			smap.Lock()
//			smap.mymap["1"] = "2"
//			smap.Unlock()
//			done <- true
//			time.Sleep(1 * time.Millisecond)
//		}
//	}()
//
//	var lastlength = 0
//	var lock sync.Mutex
//	go func() {
//		for {
//			if len(done) != lastlength {
//				lock.Lock()
//				lastlength = len(done)
//				lock.Unlock()
//
//				smap.RLock()
//				fmt.Print(smap.mymap["1"], "\t")
//				if len(done)%5 == 0 {
//					fmt.Println("  ", lastlength)
//				}
//				smap.RUnlock()
//			}
//		}
//	}()
//
//	for {
//		if len(done) == 1000 {
//			fmt.Println("通道已经满了")
//			break
//		} else {
//			time.Sleep(1 * time.Second)
//		}
//	}
//}

//type threadSafeSet struct {
//	sync.RWMutex
//	s []interface{}
//}
//
//func (set *threadSafeSet) Iter() <-chan interface{} {
//	// ch := make(chan interface{}) // 解除注释看看！
//	ch := make(chan interface{}, len(set.s))
//	go func() {
//		set.RLock()
//
//		for elem, value := range set.s {
//			ch <- elem
//			println("Iter:", elem, value)
//		}
//
//		close(ch)
//		set.RUnlock()
//
//	}()
//	return ch
//}
//
//func main() {
//
//	th := threadSafeSet{
//		s: []interface{}{"1", "2", "3"},
//	}
//	v := <-th.Iter()
//	fmt.Sprintf("%s%v", "ch", v)
//}

//type People interface {
//	Speak(string) string
//}
//
//type stduent struct{}
//
//func (stu stduent) Speak(think string) (talk string) {
//	if think == "bitch" {
//		talk = "You are a good boy"
//	} else {
//		talk = "hi"
//	}
//	return
//}
//
//func main() {
//	var peo People = &stduent{}
//	think := "bitch"
//	fmt.Println(peo.Speak(think))
//}

//type People interface {
//	Show()
//}
//
//type Student struct{}
//
//func (stu *Student) Show() {
//
//}
//
//func live() People {
//	var stu *Student
//	return stu
//}
//
//func main() {
//	fmt.Println(live())
//	if live() == nil {
//		fmt.Println("AAAAAAA")
//	} else {
//		fmt.Println("BBBBBBB")
//	}
//}

//type students struct {
//	Name string
//	Age  int
//}
//
//func pase_student() {
//	m := make(map[string]*students)
//	stus := []students{
//		{Name: "zhou", Age: 24},
//		{Name: "li", Age: 23},
//		{Name: "wang", Age: 22},
//	}
//	for _, stu := range stus {
//		m[stu.Name] = &stu
//		fmt.Println(stu)
//		fmt.Printf("%p \n", &stu)
//	}
//	fmt.Print(m)
//
//}
//
//func main() {
//	pase_student()
//}

//func main() {
//	list := new([]int)
//	*list = append(*list, 1)
//	fmt.Println(*list)
//}

//type students struct {
//	name string
//}
//
//var list map[string]*students
//
//func main() {
//	list = make(map[string]*students)
//	student := students{"Aceld"}
//	//list["student"] = student
//	//tmpstudent := list["student"]
//	//tmpstudent.name = "LDB"
//	////list["student"].name = "456"
//
//	list["student"] = &student
//	list["student"].name = "LDB"
//
//	fmt.Println(list["student"])
//}

//type students struct {
//	Name string
//	Age  int
//}
//
//func main() {
//	//定义map
//	m := make(map[string]*students)
//	//定义student数组
//	stus := []students{
//		{Name: "zhou", Age: 24},
//		{Name: "li", Age: 23},
//		{Name: "wang", Age: 22},
//	}
//	//将数组依次添加到map中
//	for i := 0; i < len(stus); i++ {
//		m[stus[i].Name] = &stus[i]
//	}
//	//打印map
//	for k, v := range m {
//		fmt.Println(k, "=>", v.Age)
//	}
//}

//func missingNumber(nums []int) int {
//
//	//二分法
//
//	beg := 0
//	end := len(nums)
//
//	for beg < end {
//
//		mid := (beg + end) / 2
//		fmt.Println(mid)
//		if nums[mid] == mid {
//			beg = mid + 1
//			fmt.Println("相同", beg, end, mid, nums[mid])
//		} else {
//			end = mid
//			fmt.Println("不相同", beg, end, mid, nums[mid])
//		}
//		fmt.Println("-------", nums[beg:end])
//
//	}
//	return beg
//
//}
//
//func main() {
//	fmt.Println(missingNumber([]int{0, 1, 2, 3, 4, 5, 6, 8, 9}))
//}

//func QuickSort(nums []int) []int {
//	// 思路：把一个数组分为左右两段，左段小于右段
//	quickSort(nums, 0, len(nums)-1)
//	return nums
//
//}
//
//// 原地交换，所以传入交换索引
//func quickSort(nums []int, start, end int) {
//	if start < end {
//		// 分治法：divide
//		pivot := partition(nums, start, end)
//		quickSort(nums, 0, pivot-1)
//		quickSort(nums, pivot+1, end)
//	}
//}
//
//// 分区
//func partition(nums []int, start, end int) int {
//	// 选取最后一个元素作为基准pivot
//	p := nums[end]
//	i := start
//	// 最后一个值就是基准所以不用比较
//	for j := start; j < end; j++ {
//		if nums[j] < p {
//			swap(nums, i, j)
//			i++
//		}
//	}
//	// 把基准值换到中间
//	swap(nums, i, end)
//	return i
//}
//
//// 交换两个元素
//func swap(nums []int, i, j int) {
//	t := nums[i]
//	nums[i] = nums[j]
//	nums[j] = t
//}
//
//func main() {
//	fmt.Println(QuickSort([]int{2, 6, 5, 4, 3, 1}))
//}

//func main() {
//	var x int = 100
//	fmt.Println(unsafe.Sizeof(x)) // 8
//	var y int64 = 1
//	fmt.Println(unsafe.Sizeof(y)) // 8
//	var y1 int32 = 1
//	fmt.Println(unsafe.Sizeof(y1)) // 4
//	var z uint64 = 1
//	fmt.Println(unsafe.Sizeof(z)) // 8
//	var z1 uint32 = 1
//	fmt.Println(unsafe.Sizeof(z1)) // 4
//	i := uint(1)
//	fmt.Println(unsafe.Sizeof(i)) // 8
//	j := float64(4.11)
//	fmt.Println(unsafe.Sizeof(j)) // 8
//	a := string("123666")
//	fmt.Println(unsafe.Sizeof(a)) // 16
//	c := bool(true)
//	fmt.Println(unsafe.Sizeof(c)) // 1
//}

//func main() {
//
//	var str = "hello 你好"
//	//golang中string底层是通过byte数组实现的，座椅直接求len 实际是在按字节长度计算  所以一个汉字占3个字节算了3个长度
//	fmt.Println("len(str):", len(str))
//	s := map[int]string{
//		1: "123",
//	}
//	a := make(map[int]string)
//	//以下两种都可以得到str的字符串长度
//
//	//golang中的unicode/utf8包提供了用utf-8获取长度的方法
//	fmt.Println("RuneCountInString:", utf8.RuneCountInString(str))
//
//	//通过rune类型处理unicode字符
//	fmt.Println("rune:", len([]rune(str)))
//	for k, v := range str {
//		fmt.Printf("v type: %T\n", v)
//		fmt.Printf("k type: %T\n", k)
//		fmt.Println(v, k)
//	}
//	fmt.Println("rune:", len([]rune(str)))
//
//}

//func main() {
//	ss := []string{
//		"ado",
//		"duzhenxun",
//		"小手25是什么",
//		"来个长点的字符串，微信号5552123",
//	}
//	tmpArr := map[int32]int{}
//	for k, v := range []int32(ss[1]) {
//		fmt.Println(k, v)
//		fmt.Println(tmpArr)
//		if tmpArr[v] != 0 && len(tmpArr) > 0 {
//			fmt.Println(v)
//			fmt.Println("有重复")
//			break
//		}
//		tmpArr[v] = k
//	}
//}

//func main() {
//	var num01 int = 0b1100
//	var num02 int = 0o14
//	var num03 int = 0xC
//
//	fmt.Printf("2进制数 %b 表示的是: %d \n", num01, num01)
//	fmt.Printf("8进制数 %o 表示的是: %d \n", num02, num02)
//	fmt.Printf("16进制数 %X 表示的是: %d \n", num03, num03)
//}

// 定义一个接口
type Good interface {
	settleAccount() int
	orderInfo() string
}

type Phone struct {
	name     string
	quantity int
	price    int
}

func (phone Phone) settleAccount() int {
	return phone.quantity * phone.price
}
func (phone Phone) orderInfo() string {
	return "您要购买" + strconv.Itoa(phone.quantity) + "个" +
		phone.name + "计：" + strconv.Itoa(phone.settleAccount()) + "元"
}

type FreeGift struct {
	name     string
	quantity int
	price    int
}

func (gift FreeGift) settleAccount() int {
	return 0
}
func (gift FreeGift) orderInfo() string {
	return "您要购买" + strconv.Itoa(gift.quantity) + "个" +
		gift.name + "计：" + strconv.Itoa(gift.settleAccount()) + "元"
}

func calculateAllPrice(goods []Good) int {
	var allPrice int
	for _, good := range goods {
		fmt.Println(good.orderInfo())
		allPrice += good.settleAccount()
	}
	return allPrice
}
func main() {
	iPhone := Phone{
		name:     "iPhone",
		quantity: 1,
		price:    8000,
	}
	earphones := FreeGift{
		name:     "耳机",
		quantity: 1,
		price:    200,
	}

	goods := []Good{iPhone, earphones}
	allPrice := calculateAllPrice(goods)
	fmt.Printf("该订单总共需要支付 %d 元", allPrice)
}

//var wg sync.WaitGroup
//
//func cat() {
//	fmt.Println("cat")
//	defer wg.Done()
//}
//
//func main() {
//	wg.Add(100)
//	go cat()
//	wg.Wait()
//
//}
